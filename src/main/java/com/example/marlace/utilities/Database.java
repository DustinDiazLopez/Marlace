package com.example.marlace.utilities;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.resource.transaction.spi.TransactionStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

/**
 * Hibernate wrapper
 */
public class Database {

    private static final Logger log = LoggerFactory.getLogger(Database.class);

    /**
     * Saves a transient object (i.e., bring a transient object to a persistent state) <b>IF</b> no identifiers exists
     * in the table it does not exist in the database. Also, returns any autogenerated identifiers.
     *
     * @param sessionFactory the hibernate session
     * @param objects        the objects to persist
     * @return list of autogenerated identifiers.
     */
    public static List<Serializable> save(final SessionFactory sessionFactory, final Object... objects) {
        return storeObjectToDatabase(sessionFactory, TransactionOption.SAVE, objects);
    }

    /**
     * Saves a transient object or updates a detached object (i.e., bring a transient or detached object to a
     * persistent state).
     *
     * @param sessionFactory the hibernate session
     * @param objects        the objects to persist
     * @return whether the commit to the database was successful.
     */
    public static boolean saveOrUpdate(final SessionFactory sessionFactory, final Object... objects) {
        List<Serializable> serializables = storeObjectToDatabase(sessionFactory, TransactionOption.SAVE_OR_UPDATE, objects);
        return serializables.size() == 1 && ((TransactionStatus) serializables.get(0)).isNotOneOf(TransactionStatus.FAILED_COMMIT);
    }

    /**
     * Saves a transient object (i.e., bring a transient object to a persistent state).
     *
     * @param sessionFactory the hibernate session
     * @param objects        the objects to persist
     * @return whether the commit to the database was successful.
     */
    public static boolean persist(final SessionFactory sessionFactory, final Object... objects) {
        List<Serializable> serializables = storeObjectToDatabase(sessionFactory, TransactionOption.PERSIST, objects);
        return serializables.size() == 1 && ((TransactionStatus) serializables.get(0)).isNotOneOf(TransactionStatus.FAILED_COMMIT);
    }

    public static Object get(final SessionFactory sessionFactory, Class cls, Integer id) {
        Session session = sessionFactory.openSession();
        Transaction transaction = session.beginTransaction();
        final Object object = session.get(cls, id);
        transaction.commit();
        return object;
    }

    public static boolean delete(final SessionFactory sessionFactory, final Object... objects) {
        Session session = sessionFactory.openSession();
        Transaction transaction = session.beginTransaction();
        for (Object obj : objects) session.delete(obj);
        transaction.commit();
        return transaction.getStatus().isNotOneOf(TransactionStatus.FAILED_COMMIT);
    }

    /**
     * @param sessionFactory hibernate session
     * @param option         {@link TransactionOption} whether to save, saveOrUpdate, or persist
     * @param objects        the objects to persist
     * @return if save: returns a list of ids
     * if saveOrUpdate or persist: returns a list with the transaction status
     */
    public static List<Serializable> storeObjectToDatabase(
            final SessionFactory sessionFactory,
            final TransactionOption option,
            final Object... objects
    ) {
        Session session = sessionFactory.openSession();
        Transaction transaction = session.beginTransaction();
        List<Serializable> ids = new ArrayList<>(objects.length);
        switch (option) {
            case SAVE:
                for (Object obj : objects) {
                    ids.add(session.save(obj));
                }
                break;
            case SAVE_OR_UPDATE:
                for (Object obj : objects) {
                    session.saveOrUpdate(obj);
                }
                break;
            case PERSIST:
                for (Object obj : objects) {
                    session.persist(obj);
                }
                break;
            default:
                log.error(option + " is not a valid Database Transaction Option");

                ids.add(TransactionStatus.FAILED_COMMIT);
                return ids;
        }

        transaction.commit();

        log.info(transaction.getStatus().toString());

        if (ids.size() == 0) {
            ids.add(transaction.getStatus());
        }

        return ids;
    }

    enum TransactionOption {
        SAVE,
        SAVE_OR_UPDATE,
        PERSIST
    }
}
